---
task_id: "002"
epic: "multi-package-chaining"
title: "依赖解析算法"
status: "in_progress"
priority: "high"
estimate: "3 hours"
depends_on: []
parallel: true
created: "2025-09-18T22:34:04Z"
updated: "2025-09-19T02:01:14Z"
github: "https://github.com/jia-xia/quick-functions/issues/3"
tags: ["algorithm", "dependencies", "topology", "foundation"]
---

# 依赖解析算法

## 概述

实现依赖解析算法，包括拓扑排序和循环依赖检测，为多包链式构建确定正确的构建顺序。

## 需求

### 功能需求

1. 实现拓扑排序算法确定包的构建顺序
2. 实现循环依赖检测机制
3. 创建 `resolve_build_order()` 核心函数
4. 提供清晰的依赖关系错误报告

### 技术需求

1. 使用深度优先搜索实现拓扑排序
2. 实现高效的循环依赖检测
3. 算法需要处理复杂的依赖图
4. 提供详细的错误信息和调试输出

## 验收标准

- [ ] `resolve_build_order()` 函数正确实现拓扑排序
- [ ] 能够检测并报告循环依赖
- [ ] 算法处理各种复杂依赖关系正确
- [ ] 提供清晰的错误消息和依赖路径信息
- [ ] 性能在合理范围内（支持数百个包）
- [ ] 包含完整的单元测试覆盖

## 实现细节

### 核心算法

#### 拓扑排序实现
```bash
resolve_build_order() {
    local packages_config="$1"
    local build_order=()
    local visited=()
    local temp_mark=()
    
    # 深度优先搜索实现
    # 返回构建顺序数组
}
```

#### 循环依赖检测
- 使用深度优先搜索标记访问状态
- 检测back edge指示循环
- 提供完整的循环路径信息

### 数据结构

1. **依赖图表示**: 使用关联数组表示邻接表
2. **访问状态跟踪**: 未访问、临时标记、永久标记
3. **构建顺序**: 输出数组，按依赖顺序排列

### 错误处理

1. **循环依赖**: 提供完整的循环路径
2. **缺失依赖**: 报告未定义的依赖包
3. **格式错误**: 验证输入数据格式

## 文件修改

主要实现文件：
- 创建或修改包含依赖解析逻辑的函数
- 可能需要独立的辅助函数文件

## 测试计划

### 测试用例

1. **简单线性依赖**: A → B → C
2. **分支依赖**: A → B, A → C
3. **汇聚依赖**: B → A, C → A
4. **复杂图**: 多层次混合依赖
5. **循环依赖**: A → B → C → A
6. **自依赖**: A → A
7. **缺失依赖**: A → 不存在的包

### 性能测试

1. 大规模依赖图（100+ 包）
2. 深层依赖链（20+ 层）
3. 复杂交叉依赖网络

## 依赖关系

- **依赖任务**: 无
- **被依赖任务**: 
  - 004.md（序列构建实现）
  - 005.md（错误处理增强）
- **并行执行**: 可与001、003任务并行开发

## 风险和注意事项

1. **算法复杂度**: 确保在合理时间内完成
2. **内存使用**: 大型依赖图的内存管理
3. **错误报告**: 循环依赖路径可能很长
4. **边界情况**: 空依赖、单包等特殊情况

## 算法示例

### 输入格式
```yaml
packages:
  pkg-a: {dependencies: []}
  pkg-b: {dependencies: ["pkg-a"]}
  pkg-c: {dependencies: ["pkg-a", "pkg-b"]}
```

### 输出格式
```bash
# 成功情况
build_order=("pkg-a" "pkg-b" "pkg-c")

# 循环依赖情况
error="Circular dependency detected: pkg-a → pkg-b → pkg-c → pkg-a"
```

## 定义完成 (Definition of Done)

- [ ] 拓扑排序算法实现正确
- [ ] 循环依赖检测功能完善
- [ ] 错误报告信息完整清晰
- [ ] 算法性能满足要求
- [ ] 单元测试覆盖率达到95%+
- [ ] 代码质量符合项目标准
- [ ] 函数接口设计合理，易于集成
