---
name: multi-package-chaining
description: 多包联动支持系统 - 支持 Package A → Package B → App C 的链式依赖构建和部署
status: backlog
created: 2025-09-18T22:21:07Z
---

# PRD: 多包联动支持系统

## 项目概述

目前的 devup 系统只支持单包到应用的加载流程（Package → App），但现实开发中经常需要多包链式依赖，如 Package A 打包给 Package B 加载，然后再打包 Package B 给 App C 加载使用。本 PRD 旨在扩展现有系统，支持链式多包依赖的自动化构建和部署，并通过函数式重构提升系统稳定性。

## 问题描述

### 当前痛点
1. **限制性架构**：现有系统只支持单一包到应用的简单流程，无法处理包间依赖
2. **手动操作复杂**：开发者需要手动管理多包构建顺序，容易出错且效率低下
3. **状态管理混乱**：当前实现中存在状态变更和副作用，在多包场景下容易产生不可预期的问题
4. **缓存一致性**：多包场景下版本号和缓存管理更加复杂

### 为什么现在重要
- 项目架构向微前端/包模块化发展，包间依赖成为常态
- 开发效率需要自动化工具支持复杂的构建链
- 函数式重构能显著提升系统可靠性和可维护性

## 用户故事

### 主要用户角色
- **前端开发者**：需要开发和测试包间依赖的功能
- **架构师**：需要设计和维护包依赖关系
- **DevOps工程师**：需要自动化构建和部署流程

### 详细用户旅程

#### 开发者工作流
1. **配置依赖链**：开发者在配置文件中声明 A→B→C 的依赖关系
2. **一键构建**：运行 `devup -chain-config` 自动处理整个依赖链
3. **实时开发**：修改 Package A 后，系统自动重新构建整个链并重启应用
4. **调试支持**：清晰的错误信息和构建状态反馈

#### 痛点解决
- **手动管理** → 声明式配置 + 自动化执行
- **构建顺序错误** → 依赖解析算法保证正确顺序
- **版本冲突** → 统一的版本号管理策略
- **状态不一致** → 函数式无副作用操作

## 需求说明

### 功能性需求

#### 核心功能
1. **链式依赖配置**
   - 支持配置文件中声明 A→B→C 依赖链
   - 依赖关系验证（循环依赖检测）
   - 链长度限制（暂定最大3级：A→B→C）

2. **自动化构建流程**
   - 按依赖顺序自动构建各包
   - 版本号统一管理（alpha + 时间戳）
   - 构建失败时的回滚机制

3. **智能缓存管理**
   - 只重建发生变更的包及其下游依赖
   - 清理过期的包文件
   - 版本冲突检测和解决

4. **扩展现有命令**
   - `devup -chain-config`：执行链式构建
   - `devup --validate-chain`：验证依赖链配置
   - `devup --show-chain [name]`：显示链式配置详情

#### 用户交互流程
1. **配置阶段**：声明依赖链关系和构建参数
2. **验证阶段**：检查配置有效性（路径、循环依赖等）
3. **构建阶段**：按拓扑顺序构建各包
4. **部署阶段**：安装最终包到目标应用
5. **启动阶段**：启动开发服务器

### 非功能性需求

#### 性能要求
- 依赖解析时间 < 1秒（对于3级链）
- 增量构建支持（只构建变更的包）
- 并行构建非依赖包（如果存在）

#### 可靠性要求
- 构建失败时自动回滚到上一个稳定状态
- 完整的构建日志记录
- 原子性操作（要么全部成功，要么全部回滚）

#### 函数式设计要求
- **纯函数**：所有核心逻辑都是纯函数，无副作用
- **不可变数据**：配置和状态使用不可变结构
- **组合性**：单包操作函数可组合成链式操作
- **可测试性**：每个函数都能独立测试

## 成功标准

### 可测量成果
1. **功能性指标**
   - 支持 A→B→C 三级依赖链配置和构建
   - 循环依赖检测准确率 100%
   - 构建成功率 > 95%（排除用户代码错误）

2. **性能指标**
   - 三级链构建时间 < 5分钟
   - 增量构建时间减少 60%以上
   - 内存使用相比当前系统增加 < 20%

3. **开发体验指标**
   - 配置复杂度：从 3个手动步骤 → 1个配置文件
   - 错误诊断时间减少 50%
   - 新手上手时间 < 30分钟

### 关键性能指标
- **MTTR（平均修复时间）**：构建失败到修复 < 5分钟
- **可用性**：支持 macOS 和 Linux 环境
- **向后兼容性**：现有单包配置无需修改即可使用

## 约束条件和假设

### 技术限制
1. **链长度限制**：最大支持3级依赖（A→B→C），不支持更长链
2. **依赖结构限制**：只支持线性依赖，不支持分支依赖（一对多）
3. **工具依赖**：需要 `pnpm`、`jq` 和 Node.js 环境

### 架构假设
1. **包管理工具**：假设所有包都使用 pnpm 作为包管理器
2. **版本策略**：使用 alpha + 时间戳版本号避免缓存问题
3. **文件系统**：假设有足够的磁盘空间存储临时包文件

### 资源限制
1. **开发时间**：预计 2-3周开发周期
2. **测试环境**：需要模拟多包依赖的测试环境
3. **文档需求**：需要更新用户文档和配置示例

## 范围之外

### 明确不包含的功能
1. **复杂依赖图**：不支持分支依赖（一个包依赖多个包）
2. **动态依赖**：不支持运行时动态修改依赖关系
3. **跨语言支持**：只支持 Node.js/JavaScript 包
4. **云构建**：不支持远程/云端构建，只支持本地构建
5. **版本回退**：不支持回退到历史版本，只支持当前版本

### 将来可能考虑的功能
- 支持更长的依赖链（4级以上）
- 图形化依赖关系可视化
- 构建性能监控和分析
- 自动化测试集成

## 依赖关系

### 外部依赖
1. **系统工具**
   - `pnpm`：包管理和构建
   - `jq`：JSON 配置文件解析
   - `find`：文件查找和清理

2. **运行环境**
   - Node.js 16+ 环境
   - macOS 或 Linux 操作系统
   - Git 用于版本控制

### 内部团队依赖
1. **当前 devup 系统**：基于现有实现进行扩展
2. **配置管理系统**：需要扩展现有配置文件格式
3. **测试基础设施**：需要创建多包测试环境

### 项目依赖
1. **现有包结构**：假设现有包已经有合理的构建脚本
2. **开发环境**：开发者本地环境配置一致性
3. **文档系统**：需要更新现有文档和示例

## 技术实施计划

### 函数式重构方向

#### 核心设计模式
1. **纯函数组合**
   ```bash
   # 单包操作（纯函数）
   build_package() { /* 无副作用的构建操作 */ }
   pack_package() { /* 无副作用的打包操作 */ }
   install_package() { /* 无副作用的安装操作 */ }
   
   # 组合成链式操作
   build_chain() {
     chain_config | validate_chain | resolve_dependencies | map build_package
   }
   ```

2. **不可变配置流**
   - 配置文件加载后变为只读结构
   - 所有转换操作返回新的数据结构，不修改原数据
   - 状态传递通过参数，避免全局状态

3. **错误处理单子模式**
   - 使用 Either 模式处理成功/失败状态
   - 链式操作中任何步骤失败都会优雅地传播错误
   - 提供清晰的错误上下文和恢复建议

#### 关键算法
1. **依赖解析算法**：拓扑排序确定构建顺序
2. **循环依赖检测**：深度优先搜索检测环
3. **增量构建决策**：基于文件修改时间和版本号的智能判断

### 配置文件扩展

#### 新配置格式
```json
{
  "configs": [
    {
      "name": "multi-package-example",
      "description": "Package A → Package B → App C",
      "type": "chain",
      "chain": [
        {
          "type": "package",
          "name": "package-a",
          "package_dir": "$HOME/dev/package-a",
          "package_name": "@scope/package-a",
          "build_command": "./pnpm run build",
          "dependencies": []
        },
        {
          "type": "package", 
          "name": "package-b",
          "package_dir": "$HOME/dev/package-b",
          "package_name": "@scope/package-b", 
          "build_command": "./pnpm run build",
          "dependencies": ["package-a"]
        },
        {
          "type": "app",
          "name": "app-c",
          "app_dir": "$HOME/dev/app-c",
          "start_command": "./pnpm start",
          "dependencies": ["package-b"]
        }
      ]
    }
  ]
}
```

### 实现阶段
1. **Phase 1**：扩展配置解析，支持链式配置
2. **Phase 2**：实现依赖解析和验证算法
3. **Phase 3**：重构现有构建函数为纯函数
4. **Phase 4**：实现链式构建协调器
5. **Phase 5**：添加错误处理和回滚机制
6. **Phase 6**：性能优化和测试

## 风险评估

### 高风险项
1. **复杂性增加**：多包依赖显著增加系统复杂度
   - 缓解措施：函数式设计降低认知负担，完善测试覆盖

2. **构建时间延长**：链式构建可能导致开发反馈周期变长
   - 缓解措施：增量构建和并行优化

3. **调试难度增加**：多包错误定位更困难
   - 缓解措施：详细的构建日志和错误上下文

### 中风险项
1. **配置复杂度**：新配置格式学习成本
2. **兼容性问题**：与现有工具链的集成问题

## 质量保证

### 测试策略
1. **单元测试**：所有纯函数 100% 测试覆盖
2. **集成测试**：完整的 A→B→C 构建流程测试
3. **边界测试**：循环依赖、路径错误等异常情况
4. **性能测试**：构建时间和资源使用测试

### 验收标准
1. **功能验收**：所有用户故事完成并通过测试
2. **性能验收**：满足所有性能指标要求
3. **兼容性验收**：现有配置无需修改即可正常使用
4. **文档验收**：完整的用户文档和开发者文档

这个PRD为多包联动支持系统提供了全面的规划，强调函数式重构方向以提升系统稳定性，同时保持与现有系统的兼容性。通过声明式配置和自动化流程，显著改善开发者在多包依赖场景下的工作效率。